<!DOCTYPE html>
<html style="width: 100%;height: 100%">

<head>
    <script src="lottie.js"></script>
</head>

<body style="background-color: grey;">
    <input id="input-json" type="file" />
    <input id="input-font" type="file" />
    <button onclick="handleClickButton()">RUN</button>
    <div id="bodymovin"></div>

    <script>
        let currentFontFamily = ''
        let currentFontBase64 = ''
        let currentJson = {}

        let loadedJson = ''
        let loadedFontBase64 = ''
        let loadedFontFamily = ''

        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))

        function loadJSON(file) {
            const reader = new FileReader()
            reader.readAsText(file, 'utf8')
            reader.onload = e => {
                loadedJson = JSON.parse(e.target.result)
                if (loadedJson && loadedJson.fonts && Array.isArray(loadedJson.fonts.list)) {
                    for (let i = 0; i < loadedJson.fonts.list.length; i++) {
                        const { fName } = loadedJson.fonts.list[i]
                        loadedFontFamily = fName
                        alert(fName)
                        break
                    }
                }
            }
        }
        function loadFont(file) {
            const reader = new FileReader()
            reader.readAsDataURL(file, 'utf8')
            reader.onload = e => {
                loadedFontBase64 = e.target.result.split('base64,')[1]
            }
        }

        window.onload = function () {
            const jsonEl = document.getElementById("input-json")
            jsonEl.addEventListener('change', e => {
                loadJSON(e.target.files[0])
            })

            const fontEl = document.getElementById("input-font")
            fontEl.addEventListener('change', e => {
                loadFont(e.target.files[0])
            })
        }

        function setData({ fontFamily, base64, json, texts }) {
            currentFontFamily = fontFamily
            currentFontBase64 = base64
            currentJson = json

            const styleEl = document.createElement('style')
            styleEl.innerHTML = `
                @font-face {
                    font-family: ${currentFontFamily};
                    src: url(data:application/font-woff;charset=utf-8;base64,${currentFontBase64});
                }
            `
            document.head.appendChild(styleEl)

            const { assets, layers } = currentJson
            const textCompMap = {}

            assets.forEach(item => {
                if (typeof item.nm === 'string' && item.nm.toLowerCase().startsWith('#text')) {
                    textCompMap[item.nm] = item
                }
            })
            const textComps = Object.keys(textCompMap)
            textComps.sort((a, b) => a > b ? 1 : a < b ? -1 : 0)
            console.log(textComps.join('\n'))
            console.log(textCompMap)

            const replaceText = (layers, text) => {
                let originalText = ''
                if (!text) text = ''

                for (let i = 0; i < layers.length; i++) {
                    const layer = layers[i]
                    if (layer.nm === '@Source') {
                        originalText = String(layer.t.d.k[0].s.t)
                        layer.t.d.k[0].s.t = text
                        console.log(layer)
                        break
                    }
                }
                layers.forEach(layer => {
                    if (layer.t &&
                        layer.t.d &&
                        layer.t.d.k &&
                        layer.t.d.k[0] &&
                        layer.t.d.k[0].s &&
                        layer.t.d.k[0].s.t &&
                        layer.t.d.k[0].s.t === originalText
                    ) {
                        layer.t.d.k[0].s.t = text
                    }
                })
            }

            textComps.forEach((name, index) => {
                replaceText(textCompMap[name].layers, texts[index])
            })
        }

        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')

        async function DrawPNG(image, x, y, width, height) {
            // return new Promise((resolve, reject) => {
            //     const canvas = document.createElement('canvas')
            //     const ctx = canvas.getContext('2d')

            //     canvas.width = width
            //     canvas.height = height

            //     ctx.drawImage(image, x, y, width, height, 0, 0, width, height)

            //     const data = canvas.toDataURL('image/png')
            //     // const data = (ctx.getImageData(0, 0, width, height)).data.buffer
            //     // const data = canvas.toBlob(blob => {
            //     //     resolve(blob)
            //     // }, 'image/png')
            //     // console.timeEnd('DrawPNG')
            //     resolve(data)
            // })

            canvas.width = width * (2 / 3)
            canvas.height = height * (2 / 3)

            ctx.clearRect(0, 0, width, height)
            ctx.drawImage(image, x, y, width, height, 0, 0, width * (2 / 3), height * (2 / 3))

            // return (ctx.getImageData(0, 0, width, height)).data.buffer
            return canvas.toDataURL('image/png')
        }

        function LoadFrames(svgElement, anim) {
            return new Promise((resolve, reject) => {
                const image = new Image()
                image.onload = async function (e) {
                    try {
                        const frames = []

                        const width = anim.animationData.w
                        const height = anim.animationData.h
                        const maxCanvasHeight = height//16777216 / width

                        let currentY = 0
                        let currentHeight = height
                        let startFrame = 0

                        for (let i = 0; i < anim.totalFrames; i++) {
                            if (currentHeight + height >= maxCanvasHeight) {
                                frames.push({
                                    startFrame,
                                    endFrame: i,
                                    base64: await DrawPNG(image, 0, currentY, width, currentHeight)
                                })
                                currentHeight = 0
                                startFrame = i + 1

                                if ((currentY + height) + maxCanvasHeight >= image.height) {
                                    frames.push({
                                        startFrame,
                                        endFrame: anim.totalFrames - 1,
                                        base64: await DrawPNG(image, 0, currentY, width, image.height - (currentY + height))
                                    })
                                    break
                                }
                            }
                            currentHeight += height
                            currentY += height

                            console.log(i)
                        }

                        resolve(frames)
                    }
                    catch (e) {
                        reject(e)
                    }
                }
                image.onerror = function (e) {
                    reject(e)
                }
                image.src = 'data:image/svg+xml,' + encodeURIComponent((new XMLSerializer).serializeToString(svgElement))
            })
        }

        let isInitialized = false
        window.addEventListener("flutterInAppWebViewPlatformReady", function (event) {
            console.log('flutter webview initialized!')
            isInitialized = true
        })

        function handleClickButton() {
            isInitialized = true
            setData({ fontFamily: loadedFontFamily, base64: loadedFontBase64, json: loadedJson, texts: [ 'VIDEOMONSTER', 'VLOG TITLE' ] })
            run()
        }

        let isRunning = false
        async function run() {
            if (isRunning) return
            if (!isInitialized) return

            const anim = lottie.loadAnimation({
                container: document.getElementById('bodymovin'),
                renderer: 'svg',
                loop: false,
                autoplay: false,
                animationData: currentJson
            })

            let currentFrame = 0
            anim.addEventListener('DOMLoaded', async function (e) {
                try {
                    await sleep(3000)
                    const now = Date.now()

                    const rootSVGElement = anim.renderer.svgElement.cloneNode(false)
                    const defsElement = document.createElement('defs')
                    rootSVGElement.appendChild(defsElement)

                    const styleEl = document.createElement('style')
                    styleEl.innerHTML = `
                        @font-face {
                            font-family: ${currentFontFamily};
                            src: url(data:application/font-woff;charset=utf-8;base64,${currentFontBase64});
                        }
                    `
                    defsElement.appendChild(styleEl)

                    const height = anim.animationData.h * anim.totalFrames
                    rootSVGElement.setAttribute('viewBox', `0 0 1920 ${height}`)
                    rootSVGElement.setAttribute('height', height)

                    const AssignFrameNumber = (node, index) => {
                        if (node.attributes) {
                            for (let i = 0; i < node.attributes.length; i++) {
                                const attribute = node.attributes[i]
                                attribute.value = attribute.value.replace(/__lottie_element/gi, `__lottie_element_frame_${index}`)
                            }
                        }

                        for (let i = 0; i < node.childNodes.length; i++) {
                            AssignFrameNumber(node.childNodes[i], index)
                        }

                        return node
                    }

                    for (let i = 0; i < anim.totalFrames; i++) {
                        lottie.goToAndStop(i, true)

                        anim.renderer.svgElement.childNodes.forEach(node => {
                            switch (node.tagName) {
                                case 'defs': {
                                    rootSVGElement.appendChild(AssignFrameNumber(node.cloneNode(true), i))
                                }
                                    break

                                case 'g': {
                                    const gElement = node.cloneNode(true)
                                    gElement.setAttribute('transform', `matrix(1,0,0,1,0,${anim.animationData.h * i})`)

                                    rootSVGElement.appendChild(AssignFrameNumber(gElement, i))
                                }
                                    break
                            }
                        })
                    }
                    // document.body.appendChild(rootSVGElement)

                    const frames = await LoadFrames(rootSVGElement, anim)
                    if (window.flutter_inappwebview) {
                        window.flutter_inappwebview.callHandler('TransferPNGData', {
                            width: anim.animationData.w * (2 / 3),
                            height: anim.animationData.h * (2 / 3),
                            frameRate: anim.animationData.fr,
                            frames
                        })
                    }
                    lottie.destroy()

                    console.log(`elapsed: ${Date.now() - now}ms`)

                    // frames.forEach(frame => {
                    //     const img = document.createElement('img')
                    //     img.src = frame.base64
                    //     document.body.appendChild(img)
                    // })
                }
                catch (e) {
                    console.log(String(e))
                    lottie.destroy()
                    isRunning = false

                    if (window.flutter_inappwebview) {
                        window.flutter_inappwebview.callHandler('TransferFailed')
                    }
                }
            })
        }
    </script>
</body>

</html>